/** THIS FILE IS AUTOMATICALLY GENERATED FROM : https://www.bitmex.com/api/explorer/swagger.json **/

// tslint:disable:max-line-length

/**
 * Public Announcements
 */
export interface Announcement {
    id: number; // format: int32
    link: string;
    title: string;
    content: string;
    date: string; // format: date-time
}

export interface Error {
    error: any;
}

/**
 * Persistent API Keys for Developers
 */
export interface APIKey {
    id: string; // maxLength: 24
    secret: string; // maxLength: 48
    name: string; // maxLength: 64
    nonce: number; // format: int64
    cidr: string; // maxLength: 18
    permissions: any[]; // default: []
    enabled: boolean;
    userId: number; // format: int32
    created: string; // format: date-time
}

/**
 * Trollbox Data
 */
export interface Chat {
    id: number; // format: int32
    date: string; // format: date-time
    user: string;
    message: string;
    html: string;
    fromBot: boolean;
    channelID: number; // format: double
}

export interface ChatChannel {
    id: number; // format: int32
    name: string;
}

export interface ConnectedUsers {
    users: number; // format: int32
    bots: number; // format: int32
}

/**
 * Raw Order and Balance Data
 */
export interface Execution {
    execID: string; // format: guid
    orderID: string; // format: guid
    clOrdID: string;
    clOrdLinkID: string;
    account: number; // format: int64
    symbol: string;
    side: string;
    lastQty: number; // format: int64
    lastPx: number; // format: double
    underlyingLastPx: number; // format: double
    lastMkt: string;
    lastLiquidityInd: string;
    simpleOrderQty: number; // format: double
    orderQty: number; // format: int64
    price: number; // format: double
    displayQty: number; // format: int64
    stopPx: number; // format: double
    pegOffsetValue: number; // format: double
    pegPriceType: string;
    currency: string;
    settlCurrency: string;
    execType: string;
    ordType: string;
    timeInForce: string;
    execInst: string;
    contingencyType: string;
    exDestination: string;
    ordStatus: string;
    triggered: string;
    workingIndicator: boolean;
    ordRejReason: string;
    simpleLeavesQty: number; // format: double
    leavesQty: number; // format: int64
    simpleCumQty: number; // format: double
    cumQty: number; // format: int64
    avgPx: number; // format: double
    commission: number; // format: double
    tradePublishIndicator: string;
    multiLegReportingType: string;
    text: string;
    trdMatchID: string; // format: guid
    execCost: number; // format: int64
    execComm: number; // format: int64
    homeNotional: number; // format: double
    foreignNotional: number; // format: double
    transactTime: string; // format: date-time
    timestamp: string; // format: date-time
}

/**
 * Swap Funding History
 */
export interface Funding {
    timestamp: string; // format: date-time
    symbol: string;
    fundingInterval: string; // format: date-time
    fundingRate: number; // format: double
    fundingRateDaily: number; // format: double
}

/**
 * Tradeable Contracts, Indices, and History
 */
export interface Instrument {
    symbol: string;
    rootSymbol: string;
    state: string;
    typ: string;
    listing: string; // format: date-time
    front: string; // format: date-time
    expiry: string; // format: date-time
    settle: string; // format: date-time
    relistInterval: string; // format: date-time
    inverseLeg: string;
    sellLeg: string;
    buyLeg: string;
    optionStrikePcnt: number; // format: double
    optionStrikeRound: number; // format: double
    optionStrikePrice: number; // format: double
    optionMultiplier: number; // format: double
    positionCurrency: string;
    underlying: string;
    quoteCurrency: string;
    underlyingSymbol: string;
    reference: string;
    referenceSymbol: string;
    calcInterval: string; // format: date-time
    publishInterval: string; // format: date-time
    publishTime: string; // format: date-time
    maxOrderQty: number; // format: int64
    maxPrice: number; // format: double
    lotSize: number; // format: int64
    tickSize: number; // format: double
    multiplier: number; // format: int64
    settlCurrency: string;
    underlyingToPositionMultiplier: number; // format: int64
    underlyingToSettleMultiplier: number; // format: int64
    quoteToSettleMultiplier: number; // format: int64
    isQuanto: boolean;
    isInverse: boolean;
    initMargin: number; // format: double
    maintMargin: number; // format: double
    riskLimit: number; // format: int64
    riskStep: number; // format: int64
    limit: number; // format: double
    capped: boolean;
    taxed: boolean;
    deleverage: boolean;
    makerFee: number; // format: double
    takerFee: number; // format: double
    settlementFee: number; // format: double
    insuranceFee: number; // format: double
    fundingBaseSymbol: string;
    fundingQuoteSymbol: string;
    fundingPremiumSymbol: string;
    fundingTimestamp: string; // format: date-time
    fundingInterval: string; // format: date-time
    fundingRate: number; // format: double
    indicativeFundingRate: number; // format: double
    rebalanceTimestamp: string; // format: date-time
    rebalanceInterval: string; // format: date-time
    openingTimestamp: string; // format: date-time
    closingTimestamp: string; // format: date-time
    sessionInterval: string; // format: date-time
    prevClosePrice: number; // format: double
    limitDownPrice: number; // format: double
    limitUpPrice: number; // format: double
    bankruptLimitDownPrice: number; // format: double
    bankruptLimitUpPrice: number; // format: double
    prevTotalVolume: number; // format: int64
    totalVolume: number; // format: int64
    volume: number; // format: int64
    volume24h: number; // format: int64
    prevTotalTurnover: number; // format: int64
    totalTurnover: number; // format: int64
    turnover: number; // format: int64
    turnover24h: number; // format: int64
    homeNotional24h: number; // format: double
    foreignNotional24h: number; // format: double
    prevPrice24h: number; // format: double
    vwap: number; // format: double
    highPrice: number; // format: double
    lowPrice: number; // format: double
    lastPrice: number; // format: double
    lastPriceProtected: number; // format: double
    lastTickDirection: string;
    lastChangePcnt: number; // format: double
    bidPrice: number; // format: double
    midPrice: number; // format: double
    askPrice: number; // format: double
    impactBidPrice: number; // format: double
    impactMidPrice: number; // format: double
    impactAskPrice: number; // format: double
    hasLiquidity: boolean;
    openInterest: number; // format: int64
    openValue: number; // format: int64
    fairMethod: string;
    fairBasisRate: number; // format: double
    fairBasis: number; // format: double
    fairPrice: number; // format: double
    markMethod: string;
    markPrice: number; // format: double
    indicativeTaxRate: number; // format: double
    indicativeSettlePrice: number; // format: double
    optionUnderlyingPrice: number; // format: double
    settledPrice: number; // format: double
    timestamp: string; // format: date-time
}

export interface InstrumentInterval {
    intervals: string[];
    symbols: string[];
}

export interface IndexComposite {
    timestamp: string; // format: date-time
    symbol: string;
    indexSymbol: string;
    reference: string;
    lastPrice: number; // format: double
    weight: number; // format: double
    logged: string; // format: date-time
}

/**
 * Insurance Fund Data
 */
export interface Insurance {
    currency: string;
    timestamp: string; // format: date-time
    walletBalance: number; // format: int64
}

/**
 * Information on Top Users
 */
export interface Leaderboard {
    name: string;
    isRealName: boolean;
    profit: number; // format: double
}

/**
 * Active Liquidations
 */
export interface Liquidation {
    orderID: string; // format: guid
    symbol: string;
    side: string;
    price: number; // format: double
    leavesQty: number; // format: int64
}

/**
 * Account Notifications
 */
export interface Notification {
    id: number; // format: int32
    date: string; // format: date-time
    title: string;
    body: string;
    ttl: number; // format: int32
    type: 'success' | 'error' | 'info';
    closable: boolean; // default: true
    persist: boolean; // default: true
    waitForVisibility: boolean; // default: true
    sound: string;
}

/**
 * Placement, Cancellation, Amending, and History
 */
export interface Order {
    orderID: string; // format: guid
    clOrdID: string;
    clOrdLinkID: string;
    account: number; // format: int64
    symbol: string;
    side: string;
    simpleOrderQty: number; // format: double
    orderQty: number; // format: int64
    price: number; // format: double
    displayQty: number; // format: int64
    stopPx: number; // format: double
    pegOffsetValue: number; // format: double
    pegPriceType: string;
    currency: string;
    settlCurrency: string;
    ordType: string;
    timeInForce: string;
    execInst: string;
    contingencyType: string;
    exDestination: string;
    ordStatus: string;
    triggered: string;
    workingIndicator: boolean;
    ordRejReason: string;
    simpleLeavesQty: number; // format: double
    leavesQty: number; // format: int64
    simpleCumQty: number; // format: double
    cumQty: number; // format: int64
    avgPx: number; // format: double
    multiLegReportingType: string;
    text: string;
    transactTime: string; // format: date-time
    timestamp: string; // format: date-time
}

export interface OrderBookL2 {
    symbol: string;
    id: number; // format: int64
    side: string;
    size: number; // format: int64
    price: number; // format: double
}

/**
 * Summary of Open and Closed Positions
 */
export interface Position {
    account: number; // format: int64
    symbol: string;
    currency: string;
    underlying: string;
    quoteCurrency: string;
    commission: number; // format: double
    initMarginReq: number; // format: double
    maintMarginReq: number; // format: double
    riskLimit: number; // format: int64
    leverage: number; // format: double
    crossMargin: boolean;
    deleveragePercentile: number; // format: double
    rebalancedPnl: number; // format: int64
    prevRealisedPnl: number; // format: int64
    prevUnrealisedPnl: number; // format: int64
    prevClosePrice: number; // format: double
    openingTimestamp: string; // format: date-time
    openingQty: number; // format: int64
    openingCost: number; // format: int64
    openingComm: number; // format: int64
    openOrderBuyQty: number; // format: int64
    openOrderBuyCost: number; // format: int64
    openOrderBuyPremium: number; // format: int64
    openOrderSellQty: number; // format: int64
    openOrderSellCost: number; // format: int64
    openOrderSellPremium: number; // format: int64
    execBuyQty: number; // format: int64
    execBuyCost: number; // format: int64
    execSellQty: number; // format: int64
    execSellCost: number; // format: int64
    execQty: number; // format: int64
    execCost: number; // format: int64
    execComm: number; // format: int64
    currentTimestamp: string; // format: date-time
    currentQty: number; // format: int64
    currentCost: number; // format: int64
    currentComm: number; // format: int64
    realisedCost: number; // format: int64
    unrealisedCost: number; // format: int64
    grossOpenCost: number; // format: int64
    grossOpenPremium: number; // format: int64
    grossExecCost: number; // format: int64
    isOpen: boolean;
    markPrice: number; // format: double
    markValue: number; // format: int64
    riskValue: number; // format: int64
    homeNotional: number; // format: double
    foreignNotional: number; // format: double
    posState: string;
    posCost: number; // format: int64
    posCost2: number; // format: int64
    posCross: number; // format: int64
    posInit: number; // format: int64
    posComm: number; // format: int64
    posLoss: number; // format: int64
    posMargin: number; // format: int64
    posMaint: number; // format: int64
    posAllowance: number; // format: int64
    taxableMargin: number; // format: int64
    initMargin: number; // format: int64
    maintMargin: number; // format: int64
    sessionMargin: number; // format: int64
    targetExcessMargin: number; // format: int64
    varMargin: number; // format: int64
    realisedGrossPnl: number; // format: int64
    realisedTax: number; // format: int64
    realisedPnl: number; // format: int64
    unrealisedGrossPnl: number; // format: int64
    longBankrupt: number; // format: int64
    shortBankrupt: number; // format: int64
    taxBase: number; // format: int64
    indicativeTaxRate: number; // format: double
    indicativeTax: number; // format: int64
    unrealisedTax: number; // format: int64
    unrealisedPnl: number; // format: int64
    unrealisedPnlPcnt: number; // format: double
    unrealisedRoePcnt: number; // format: double
    simpleQty: number; // format: double
    simpleCost: number; // format: double
    simpleValue: number; // format: double
    simplePnl: number; // format: double
    simplePnlPcnt: number; // format: double
    avgCostPrice: number; // format: double
    avgEntryPrice: number; // format: double
    breakEvenPrice: number; // format: double
    marginCallPrice: number; // format: double
    liquidationPrice: number; // format: double
    bankruptPrice: number; // format: double
    timestamp: string; // format: date-time
    lastPrice: number; // format: double
    lastValue: number; // format: int64
}

/**
 * Best Bid/Offer Snapshots & Historical Bins
 */
export interface Quote {
    timestamp: string; // format: date-time
    symbol: string;
    bidSize: number; // format: int64
    bidPrice: number; // format: double
    askPrice: number; // format: double
    askSize: number; // format: int64
}

/**
 * Historical Settlement Data
 */
export interface Settlement {
    timestamp: string; // format: date-time
    symbol: string;
    settlementType: string;
    settledPrice: number; // format: double
    optionStrikePrice: number; // format: double
    optionUnderlyingPrice: number; // format: double
    bankrupt: number; // format: int64
    taxBase: number; // format: int64
    taxRate: number; // format: double
}

/**
 * Exchange Statistics
 */
export interface Stats {
    rootSymbol: string;
    currency: string;
    volume24h: number; // format: int64
    turnover24h: number; // format: int64
    openInterest: number; // format: int64
    openValue: number; // format: int64
}

export interface StatsHistory {
    date: string; // format: date-time
    rootSymbol: string;
    currency: string;
    volume: number; // format: int64
    turnover: number; // format: int64
}

export interface StatsUSD {
    rootSymbol: string;
    currency: string;
    turnover24h: number; // format: int64
    turnover30d: number; // format: int64
    turnover365d: number; // format: int64
    turnover: number; // format: int64
}

/**
 * Individual & Bucketed Trades
 */
export interface Trade {
    timestamp: string; // format: date-time
    symbol: string;
    side: string;
    size: number; // format: int64
    price: number; // format: double
    tickDirection: string;
    trdMatchID: string; // format: guid
    grossValue: number; // format: int64
    homeNotional: number; // format: double
    foreignNotional: number; // format: double
}

export interface TradeBin {
    timestamp: string; // format: date-time
    symbol: string;
    open: number; // format: double
    high: number; // format: double
    low: number; // format: double
    close: number; // format: double
    trades: number; // format: int64
    volume: number; // format: int64
    vwap: number; // format: double
    lastSize: number; // format: int64
    turnover: number; // format: int64
    homeNotional: number; // format: double
    foreignNotional: number; // format: double
}

export interface Wallet {
    account: number; // format: int64
    currency: string;
    prevDeposited: number; // format: int64
    prevWithdrawn: number; // format: int64
    prevTransferIn: number; // format: int64
    prevTransferOut: number; // format: int64
    prevAmount: number; // format: int64
    prevTimestamp: string; // format: date-time
    deltaDeposited: number; // format: int64
    deltaWithdrawn: number; // format: int64
    deltaTransferIn: number; // format: int64
    deltaTransferOut: number; // format: int64
    deltaAmount: number; // format: int64
    deposited: number; // format: int64
    withdrawn: number; // format: int64
    transferIn: number; // format: int64
    transferOut: number; // format: int64
    amount: number; // format: int64
    pendingCredit: number; // format: int64
    pendingDebit: number; // format: int64
    confirmedDebit: number; // format: int64
    timestamp: string; // format: date-time
    addr: string;
    script: string;
    withdrawalLock: string[];
}

export interface Transaction {
    transactID: string; // format: guid
    account: number; // format: int64
    currency: string;
    transactType: string;
    amount: number; // format: int64
    fee: number; // format: int64
    transactStatus: string;
    address: string;
    tx: string;
    text: string;
    transactTime: string; // format: date-time
    timestamp: string; // format: date-time
}

export interface AccessToken {
    id: string;
    ttl: number; // format: double, default: 1209600
    created: string; // format: date-time
    userId: number; // format: double
}

export interface Affiliate {
    account: number; // format: int64
    currency: string;
    prevPayout: number; // format: int64
    prevTurnover: number; // format: int64
    prevComm: number; // format: int64
    prevTimestamp: string; // format: date-time
    execTurnover: number; // format: int64
    execComm: number; // format: int64
    totalReferrals: number; // format: int64
    totalTurnover: number; // format: int64
    totalComm: number; // format: int64
    payoutPcnt: number; // format: double
    pendingPayout: number; // format: int64
    timestamp: string; // format: date-time
    referrerAccount: number; // format: double
    referralDiscount: number; // format: double
}

/**
 * Account Operations
 */
export interface User {
    id: number; // format: int32
    ownerId: number; // format: int32
    firstname: string;
    lastname: string;
    username: string;
    email: string;
    phone: string;
    created: string; // format: date-time
    lastUpdated: string; // format: date-time
    preferences: UserPreferences; // default: {}
    TFAEnabled: string;
    affiliateID: string; // maxLength: 6
    pgpPubKey: string; // maxLength: 16384
    country: string; // maxLength: 3
    geoipCountry: string; // maxLength: 2
    geoipRegion: string; // maxLength: 2
    typ: string;
}

export interface UserCommission {
    makerFee: number; // format: double
    takerFee: number; // format: double
    settlementFee: number; // format: double
    maxFee: number; // format: double
}

export interface Margin {
    account: number; // format: int64
    currency: string;
    riskLimit: number; // format: int64
    prevState: string;
    state: string;
    action: string;
    amount: number; // format: int64
    pendingCredit: number; // format: int64
    pendingDebit: number; // format: int64
    confirmedDebit: number; // format: int64
    prevRealisedPnl: number; // format: int64
    prevUnrealisedPnl: number; // format: int64
    grossComm: number; // format: int64
    grossOpenCost: number; // format: int64
    grossOpenPremium: number; // format: int64
    grossExecCost: number; // format: int64
    grossMarkValue: number; // format: int64
    riskValue: number; // format: int64
    taxableMargin: number; // format: int64
    initMargin: number; // format: int64
    maintMargin: number; // format: int64
    sessionMargin: number; // format: int64
    targetExcessMargin: number; // format: int64
    varMargin: number; // format: int64
    realisedPnl: number; // format: int64
    unrealisedPnl: number; // format: int64
    indicativeTax: number; // format: int64
    unrealisedProfit: number; // format: int64
    syntheticMargin: number; // format: int64
    walletBalance: number; // format: int64
    marginBalance: number; // format: int64
    marginBalancePcnt: number; // format: double
    marginLeverage: number; // format: double
    marginUsedPcnt: number; // format: double
    excessMargin: number; // format: int64
    excessMarginPcnt: number; // format: double
    availableMargin: number; // format: int64
    withdrawableMargin: number; // format: int64
    timestamp: string; // format: date-time
    grossLastValue: number; // format: int64
    commission: number; // format: double
}

export interface UserPreferences {
    alertOnLiquidations: boolean;
    animationsEnabled: boolean;
    announcementsLastSeen: string; // format: date-time
    chatChannelID: number; // format: double
    colorTheme: string;
    currency: string;
    debug: boolean;
    disableEmails: string[];
    hideConfirmDialogs: string[];
    hideConnectionModal: boolean;
    hideFromLeaderboard: boolean;
    hideNameFromLeaderboard: boolean; // default: true
    hideNotifications: string[];
    locale: string; // default: en-US
    msgsSeen: string[];
    orderBookBinning: any;
    orderBookType: string;
    orderClearImmediate: boolean;
    orderControlsPlusMinus: boolean;
    showLocaleNumbers: boolean; // default: true
    sounds: string[];
    strictIPCheck: boolean;
    strictTimeout: boolean; // default: true
    tickerGroup: string;
    tickerPinned: boolean;
    tradeLayout: string;
}

export interface AnnouncementQuery {

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     */
    columns?: string;
}

export interface ApiKeyPost {

    /**
     * Key name. This name is for reference only.
     */
    name?: string;

    /**
     * CIDR block to restrict this key to. To restrict to a single address, append "/32", e.g. 207.39.29.22/32. Leave blank or set to 0.0.0.0/0 to allow all IPs. Only one block may be set. <a href="http://software77.net/cidr-101.html">More on CIDR blocks</a>
     */
    cidr?: string;

    /**
     * Key Permissions. All keys can read margin and position data. Additional permissions must be added. Available: ["order", "orderCancel", "withdraw"].
     */
    permissions?: string;

    /**
     * Set to true to enable this key on creation. Otherwise, it must be explicitly enabled via /apiKey/enable.
     */
    enabled?: boolean; // DEFAULT: false

    /**
     * OTP Token (YubiKey, Google Authenticator)
     */
    token?: string;
}

export interface ApiKeyQuery {

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false
}

export interface ApiKeyDelete {

    /**
     * API Key ID (public component).
     */
    apiKeyID: string;
}

export interface ApiKeyDisablePost {

    /**
     * API Key ID (public component).
     */
    apiKeyID: string;
}

export interface ApiKeyEnablePost {

    /**
     * API Key ID (public component).
     */
    apiKeyID: string;
}

export interface ChatQuery {

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting ID for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: true

    /**
     * Channel id. GET /chat/channels for ids. Leave blank for all.
     */
    channelID?: number;
}

export interface ChatPost {

    message: string;

    /**
     * Channel to post to. Default 1 (English).
     */
    channelID?: number; // DEFAULT: 1
}

export interface ExecutionQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface ExecutionTradeHistoryQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface FundingQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface InstrumentQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface InstrumentCompositeIndexQuery {

    /**
     * The composite index symbol.
     */
    symbol?: string; // DEFAULT: .XBT

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface InsuranceQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface LeaderboardQuery {

    /**
     * Ranking type. Options: "notional", "ROE"
     */
    method?: 'notional' | 'ROE'; // DEFAULT: notional
}

export interface LiquidationQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface OrderQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface OrderPost {

    /**
     * Instrument symbol. e.g. 'XBTUSD'.
     */
    symbol: string;

    /**
     * Order side. Valid options: Buy, Sell. Defaults to 'Buy' unless `orderQty` or `simpleOrderQty` is negative.
     */
    side?: 'Buy' | 'Sell';

    /**
     * Order quantity in units of the underlying instrument (i.e. Bitcoin).
     */
    simpleOrderQty?: number;

    /**
     * Order quantity in units of the instrument (i.e. contracts).
     */
    orderQty?: number;

    /**
     * Optional limit price for 'Limit', 'StopLimit', and 'LimitIfTouched' orders.
     */
    price?: number;

    /**
     * Optional quantity to display in the book. Use 0 for a fully hidden order.
     */
    displayQty?: number;

    /**
     * Optional trigger price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders. Use a price below the current price for stop-sell orders and buy-if-touched orders. Use `execInst` of 'MarkPrice' or 'LastPrice' to define the current price used for triggering.
     */
    stopPx?: number;

    /**
     * Optional Client Order ID. This clOrdID will come back on the order and any related executions.
     */
    clOrdID?: string;

    /**
     * Optional Client Order Link ID for contingent orders.
     */
    clOrdLinkID?: string;

    /**
     * Optional trailing offset from the current price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders; use a negative offset for stop-sell orders and buy-if-touched orders. Optional offset from the peg price for 'Pegged' orders.
     */
    pegOffsetValue?: number;

    /**
     * Optional peg price type. Valid options: LastPeg, MidPricePeg, MarketPeg, PrimaryPeg, TrailingStopPeg.
     */
    pegPriceType?: 'LastPeg' | 'MidPricePeg' | 'MarketPeg' | 'PrimaryPeg' | 'TrailingStopPeg';

    /**
     * Order type. Valid options: Market, Limit, Stop, StopLimit, MarketIfTouched, LimitIfTouched, MarketWithLeftOverAsLimit, Pegged. Defaults to 'Limit' when `price` is specified. Defaults to 'Stop' when `stopPx` is specified. Defaults to 'StopLimit' when `price` and `stopPx` are specified.
     */
    ordType?: 'Market' | 'Limit' | 'Stop' | 'StopLimit' | 'MarketIfTouched' | 'LimitIfTouched' | 'MarketWithLeftOverAsLimit' | 'Pegged'; // DEFAULT: Limit

    /**
     * Time in force. Valid options: Day, GoodTillCancel, ImmediateOrCancel, FillOrKill. Defaults to 'GoodTillCancel' for 'Limit', 'StopLimit', 'LimitIfTouched', and 'MarketWithLeftOverAsLimit' orders.
     */
    timeInForce?: 'Day' | 'GoodTillCancel' | 'ImmediateOrCancel' | 'FillOrKill';

    /**
     * Optional execution instructions. Valid options: ParticipateDoNotInitiate, AllOrNone, MarkPrice, IndexPrice, LastPrice, Close, ReduceOnly, Fixed. 'AllOrNone' instruction requires `displayQty` to be 0. 'MarkPrice', 'IndexPrice' or 'LastPrice' instruction valid for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders.
     */
    execInst?: 'ParticipateDoNotInitiate' | 'AllOrNone' | 'MarkPrice' | 'IndexPrice' | 'LastPrice' | 'Close' | 'ReduceOnly' | 'Fixed';

    /**
     * Optional contingency type for use with `clOrdLinkID`. Valid options: OneCancelsTheOther, OneTriggersTheOther, OneUpdatesTheOtherAbsolute, OneUpdatesTheOtherProportional.
     */
    contingencyType?: 'OneCancelsTheOther' | 'OneTriggersTheOther' | 'OneUpdatesTheOtherAbsolute' | 'OneUpdatesTheOtherProportional';

    /**
     * Optional order annotation. e.g. 'Take profit'.
     */
    text?: string;
}

export interface OrderPut {

    /**
     * Order ID
     */
    orderID?: string;

    /**
     * Client Order ID. See POST /order.
     */
    origClOrdID?: string;

    /**
     * Optional new Client Order ID, requires `origClOrdID`.
     */
    clOrdID?: string;

    /**
     * Optional order quantity in units of the underlying instrument (i.e. Bitcoin).
     */
    simpleOrderQty?: number;

    /**
     * Optional order quantity in units of the instrument (i.e. contracts).
     */
    orderQty?: number;

    /**
     * Optional leaves quantity in units of the underlying instrument (i.e. Bitcoin). Useful for amending partially filled orders.
     */
    simpleLeavesQty?: number;

    /**
     * Optional leaves quantity in units of the instrument (i.e. contracts). Useful for amending partially filled orders.
     */
    leavesQty?: number;

    /**
     * Optional limit price for 'Limit', 'StopLimit', and 'LimitIfTouched' orders.
     */
    price?: number;

    /**
     * Optional trigger price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders. Use a price below the current price for stop-sell orders and buy-if-touched orders.
     */
    stopPx?: number;

    /**
     * Optional trailing offset from the current price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders; use a negative offset for stop-sell orders and buy-if-touched orders. Optional offset from the peg price for 'Pegged' orders.
     */
    pegOffsetValue?: number;

    /**
     * Optional amend annotation. e.g. 'Adjust skew'.
     */
    text?: string;
}

export interface OrderDelete {

    /**
     * Order ID(s).
     */
    orderID?: string;

    /**
     * Client Order ID(s). See POST /order.
     */
    clOrdID?: string;

    /**
     * Optional cancellation annotation. e.g. 'Spread Exceeded'.
     */
    text?: string;
}

export interface OrderBulkPost {

    /**
     * An array of orders.
     */
    orders?: string;
}

export interface OrderBulkPut {

    /**
     * An array of orders.
     */
    orders?: string;
}

export interface OrderClosePositionPost {

    /**
     * Symbol of position to close.
     */
    symbol: string;

    /**
     * Optional limit price.
     */
    price?: number;
}

export interface OrderAllDelete {

    /**
     * Optional symbol. If provided, only cancels orders for that symbol.
     */
    symbol?: string;

    /**
     * Optional filter for cancellation. Use to only cancel some orders, e.g. `{"side": "Buy"}`.
     */
    filter?: string;

    /**
     * Optional cancellation annotation. e.g. 'Spread Exceeded'
     */
    text?: string;
}

export interface OrderCancelAllAfterPost {

    /**
     * Timeout in ms. Set to 0 to cancel this timer.
     */
    timeout: number;
}

export interface OrderBookL2Query {

    /**
     * Instrument symbol. Send a series (e.g. XBT) to get data for the nearest contract in that series.
     */
    symbol: string;

    /**
     * Orderbook depth per side. Send 0 for full depth.
     */
    depth?: number; // DEFAULT: 25
}

export interface PositionQuery {

    /**
     * Table filter. For example, send {"symbol": "XBTUSD"}.
     */
    filter?: string;

    /**
     * Which columns to fetch. For example, send ["columnName"].
     */
    columns?: string;

    /**
     * Number of rows to fetch.
     */
    count?: number;
}

export interface PositionIsolatePost {

    /**
     * Position symbol to isolate.
     */
    symbol: string;

    /**
     * True for isolated margin, false for cross margin.
     */
    enabled?: boolean; // DEFAULT: true
}

export interface PositionRiskLimitPost {

    /**
     * Symbol of position to update risk limit on.
     */
    symbol: string;

    /**
     * New Risk Limit, in Satoshis.
     */
    riskLimit: number;
}

export interface PositionTransferMarginPost {

    /**
     * Symbol of position to isolate.
     */
    symbol: string;

    /**
     * Amount to transfer, in Satoshis. May be negative.
     */
    amount: number;
}

export interface PositionLeveragePost {

    /**
     * Symbol of position to adjust.
     */
    symbol: string;

    /**
     * Leverage value. Send a number between 0.01 and 100 to enable isolated margin with a fixed leverage. Send 0 to enable cross margin.
     */
    leverage: number;
}

export interface QuoteQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface QuoteBucketedQuery {

    /**
     * Time interval to bucket by. Available options: [1m,5m,1h,1d].
     */
    binSize?: '1m' | '5m' | '1h' | '1d'; // DEFAULT: 1m

    /**
     * If true, will send in-progress (incomplete) bins for the current time period.
     */
    partial?: boolean; // DEFAULT: false

    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface SchemaQuery {

    /**
     * Optional model filter. If omitted, will return all models.
     */
    model?: string;
}

export interface SettlementQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface TradeQuery {

    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface TradeBucketedQuery {

    /**
     * Time interval to bucket by. Available options: [1m,5m,1h,1d].
     */
    binSize?: '1m' | '5m' | '1h' | '1d'; // DEFAULT: 1m

    /**
     * If true, will send in-progress (incomplete) bins for the current time period.
     */
    partial?: boolean; // DEFAULT: false

    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;

    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;

    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;

    /**
     * Number of results to fetch.
     */
    count?: number; // DEFAULT: 100

    /**
     * Starting point for results.
     */
    start?: number; // DEFAULT: 0

    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean; // DEFAULT: false

    /**
     * Starting date filter for results.
     */
    startTime?: string;

    /**
     * Ending date filter for results.
     */
    endTime?: string;
}

export interface UserDepositAddressQuery {

    currency?: string; // DEFAULT: XBt
}

export interface UserWalletQuery {

    currency?: string; // DEFAULT: XBt
}

export interface UserWalletHistoryQuery {

    currency?: string; // DEFAULT: XBt
}

export interface UserWalletSummaryQuery {

    currency?: string; // DEFAULT: XBt
}

export interface UserExecutionHistoryQuery {

    symbol?: string; // DEFAULT: XBTUSD

    timestamp?: string; // DEFAULT: 2017-02-13T12:00:00.000Z
}

export interface UserMinWithdrawalFeeQuery {

    currency?: string; // DEFAULT: XBt
}

export interface UserRequestWithdrawalPost {

    /**
     * 2FA token. Required if 2FA is enabled on your account.
     */
    otpToken?: string;

    /**
     * Currency you're withdrawing. Options: `XBt`
     */
    currency?: 'XBt'; // DEFAULT: XBt

    /**
     * Amount of withdrawal currency.
     */
    amount: number;

    /**
     * Destination Address.
     */
    address: string;

    /**
     * Network fee for Bitcoin withdrawals. If not specified, a default value will be calculated based on Bitcoin network conditions. You will have a chance to confirm this via email.
     */
    fee?: number;
}

export interface UserCancelWithdrawalPost {

    token: string;
}

export interface UserConfirmWithdrawalPost {

    token: string;
}

export interface UserRequestEnableTFAPost {

    /**
     * Two-factor auth type. Supported types: 'GA' (Google Authenticator)
     */
    type?: string;
}

export interface UserConfirmEnableTFAPost {

    /**
     * Two-factor auth type. Supported types: 'GA' (Google Authenticator), 'Yubikey'
     */
    type?: string;

    /**
     * Token from your selected TFA type.
     */
    token: string;
}

export interface UserDisableTFAPost {

    /**
     * Two-factor auth type. Supported types: 'GA' (Google Authenticator)
     */
    type?: string;

    /**
     * Token from your selected TFA type.
     */
    token: string;
}

export interface UserConfirmEmailPost {

    token: string;
}

export interface UserCheckReferralCodeQuery {

    referralCode?: string;
}

export interface UserPreferencesPost {

    prefs: string;

    /**
     * If true, will overwrite all existing preferences.
     */
    overwrite?: boolean; // DEFAULT: false
}

export interface UserPut {

    oldPassword?: string;

    newPassword?: string;

    newPasswordConfirm?: string;

    /**
     * Username can only be set once. To reset, email support.
     */
    username?: string;

    /**
     * Country of residence.
     */
    country?: string;

    /**
     * PGP Public Key. If specified, automated emails will be sentwith this key.
     */
    pgpPubKey?: string;
}

export interface UserMarginQuery {

    currency?: string; // DEFAULT: XBt
}
