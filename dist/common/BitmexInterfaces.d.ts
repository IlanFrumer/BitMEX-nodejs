/** THIS FILE IS AUTOMATICALLY GENERATED FROM : https://www.bitmex.com/api/explorer/swagger.json **/
/**
 * Public Announcements
 */
export interface Announcement {
    id: number;
    link: string;
    title: string;
    content: string;
    date: string;
}
export interface Error {
    error: any;
}
/**
 * Persistent API Keys for Developers
 */
export interface APIKey {
    id: string;
    secret: string;
    name: string;
    nonce: number;
    cidr: string;
    permissions: any[];
    enabled: boolean;
    userId: number;
    created: string;
}
/**
 * Trollbox Data
 */
export interface Chat {
    id: number;
    date: string;
    user: string;
    message: string;
    html: string;
    fromBot: boolean;
    channelID: number;
}
export interface ChatChannel {
    id: number;
    name: string;
}
export interface ConnectedUsers {
    users: number;
    bots: number;
}
/**
 * Raw Order and Balance Data
 */
export interface Execution {
    execID: string;
    orderID: string;
    clOrdID: string;
    clOrdLinkID: string;
    account: number;
    symbol: string;
    side: string;
    lastQty: number;
    lastPx: number;
    underlyingLastPx: number;
    lastMkt: string;
    lastLiquidityInd: string;
    simpleOrderQty: number;
    orderQty: number;
    price: number;
    displayQty: number;
    stopPx: number;
    pegOffsetValue: number;
    pegPriceType: string;
    currency: string;
    settlCurrency: string;
    execType: string;
    ordType: string;
    timeInForce: string;
    execInst: string;
    contingencyType: string;
    exDestination: string;
    ordStatus: string;
    triggered: string;
    workingIndicator: boolean;
    ordRejReason: string;
    simpleLeavesQty: number;
    leavesQty: number;
    simpleCumQty: number;
    cumQty: number;
    avgPx: number;
    commission: number;
    tradePublishIndicator: string;
    multiLegReportingType: string;
    text: string;
    trdMatchID: string;
    execCost: number;
    execComm: number;
    homeNotional: number;
    foreignNotional: number;
    transactTime: string;
    timestamp: string;
}
/**
 * Swap Funding History
 */
export interface Funding {
    timestamp: string;
    symbol: string;
    fundingInterval: string;
    fundingRate: number;
    fundingRateDaily: number;
}
/**
 * Tradeable Contracts, Indices, and History
 */
export interface Instrument {
    symbol: string;
    rootSymbol: string;
    state: string;
    typ: string;
    listing: string;
    front: string;
    expiry: string;
    settle: string;
    relistInterval: string;
    inverseLeg: string;
    sellLeg: string;
    buyLeg: string;
    optionStrikePcnt: number;
    optionStrikeRound: number;
    optionStrikePrice: number;
    optionMultiplier: number;
    positionCurrency: string;
    underlying: string;
    quoteCurrency: string;
    underlyingSymbol: string;
    reference: string;
    referenceSymbol: string;
    calcInterval: string;
    publishInterval: string;
    publishTime: string;
    maxOrderQty: number;
    maxPrice: number;
    lotSize: number;
    tickSize: number;
    multiplier: number;
    settlCurrency: string;
    underlyingToPositionMultiplier: number;
    underlyingToSettleMultiplier: number;
    quoteToSettleMultiplier: number;
    isQuanto: boolean;
    isInverse: boolean;
    initMargin: number;
    maintMargin: number;
    riskLimit: number;
    riskStep: number;
    limit: number;
    capped: boolean;
    taxed: boolean;
    deleverage: boolean;
    makerFee: number;
    takerFee: number;
    settlementFee: number;
    insuranceFee: number;
    fundingBaseSymbol: string;
    fundingQuoteSymbol: string;
    fundingPremiumSymbol: string;
    fundingTimestamp: string;
    fundingInterval: string;
    fundingRate: number;
    indicativeFundingRate: number;
    rebalanceTimestamp: string;
    rebalanceInterval: string;
    openingTimestamp: string;
    closingTimestamp: string;
    sessionInterval: string;
    prevClosePrice: number;
    limitDownPrice: number;
    limitUpPrice: number;
    bankruptLimitDownPrice: number;
    bankruptLimitUpPrice: number;
    prevTotalVolume: number;
    totalVolume: number;
    volume: number;
    volume24h: number;
    prevTotalTurnover: number;
    totalTurnover: number;
    turnover: number;
    turnover24h: number;
    homeNotional24h: number;
    foreignNotional24h: number;
    prevPrice24h: number;
    vwap: number;
    highPrice: number;
    lowPrice: number;
    lastPrice: number;
    lastPriceProtected: number;
    lastTickDirection: string;
    lastChangePcnt: number;
    bidPrice: number;
    midPrice: number;
    askPrice: number;
    impactBidPrice: number;
    impactMidPrice: number;
    impactAskPrice: number;
    hasLiquidity: boolean;
    openInterest: number;
    openValue: number;
    fairMethod: string;
    fairBasisRate: number;
    fairBasis: number;
    fairPrice: number;
    markMethod: string;
    markPrice: number;
    indicativeTaxRate: number;
    indicativeSettlePrice: number;
    optionUnderlyingPrice: number;
    settledPrice: number;
    timestamp: string;
}
export interface InstrumentInterval {
    intervals: string[];
    symbols: string[];
}
export interface IndexComposite {
    timestamp: string;
    symbol: string;
    indexSymbol: string;
    reference: string;
    lastPrice: number;
    weight: number;
    logged: string;
}
/**
 * Insurance Fund Data
 */
export interface Insurance {
    currency: string;
    timestamp: string;
    walletBalance: number;
}
/**
 * Information on Top Users
 */
export interface Leaderboard {
    name: string;
    isRealName: boolean;
    profit: number;
}
/**
 * Active Liquidations
 */
export interface Liquidation {
    orderID: string;
    symbol: string;
    side: string;
    price: number;
    leavesQty: number;
}
/**
 * Account Notifications
 */
export interface GlobalNotification {
    id: number;
    date: string;
    title: string;
    body: string;
    ttl: number;
    type: 'success' | 'error' | 'info';
    closable: boolean;
    persist: boolean;
    waitForVisibility: boolean;
    sound: string;
}
/**
 * Placement, Cancellation, Amending, and History
 */
export interface Order {
    orderID: string;
    clOrdID: string;
    clOrdLinkID: string;
    account: number;
    symbol: string;
    side: string;
    simpleOrderQty: number;
    orderQty: number;
    price: number;
    displayQty: number;
    stopPx: number;
    pegOffsetValue: number;
    pegPriceType: string;
    currency: string;
    settlCurrency: string;
    ordType: string;
    timeInForce: string;
    execInst: string;
    contingencyType: string;
    exDestination: string;
    ordStatus: string;
    triggered: string;
    workingIndicator: boolean;
    ordRejReason: string;
    simpleLeavesQty: number;
    leavesQty: number;
    simpleCumQty: number;
    cumQty: number;
    avgPx: number;
    multiLegReportingType: string;
    text: string;
    transactTime: string;
    timestamp: string;
}
export interface OrderBookL2 {
    symbol: string;
    id: number;
    side: string;
    size: number;
    price: number;
}
/**
 * Summary of Open and Closed Positions
 */
export interface Position {
    account: number;
    symbol: string;
    currency: string;
    underlying: string;
    quoteCurrency: string;
    commission: number;
    initMarginReq: number;
    maintMarginReq: number;
    riskLimit: number;
    leverage: number;
    crossMargin: boolean;
    deleveragePercentile: number;
    rebalancedPnl: number;
    prevRealisedPnl: number;
    prevUnrealisedPnl: number;
    prevClosePrice: number;
    openingTimestamp: string;
    openingQty: number;
    openingCost: number;
    openingComm: number;
    openOrderBuyQty: number;
    openOrderBuyCost: number;
    openOrderBuyPremium: number;
    openOrderSellQty: number;
    openOrderSellCost: number;
    openOrderSellPremium: number;
    execBuyQty: number;
    execBuyCost: number;
    execSellQty: number;
    execSellCost: number;
    execQty: number;
    execCost: number;
    execComm: number;
    currentTimestamp: string;
    currentQty: number;
    currentCost: number;
    currentComm: number;
    realisedCost: number;
    unrealisedCost: number;
    grossOpenCost: number;
    grossOpenPremium: number;
    grossExecCost: number;
    isOpen: boolean;
    markPrice: number;
    markValue: number;
    riskValue: number;
    homeNotional: number;
    foreignNotional: number;
    posState: string;
    posCost: number;
    posCost2: number;
    posCross: number;
    posInit: number;
    posComm: number;
    posLoss: number;
    posMargin: number;
    posMaint: number;
    posAllowance: number;
    taxableMargin: number;
    initMargin: number;
    maintMargin: number;
    sessionMargin: number;
    targetExcessMargin: number;
    varMargin: number;
    realisedGrossPnl: number;
    realisedTax: number;
    realisedPnl: number;
    unrealisedGrossPnl: number;
    longBankrupt: number;
    shortBankrupt: number;
    taxBase: number;
    indicativeTaxRate: number;
    indicativeTax: number;
    unrealisedTax: number;
    unrealisedPnl: number;
    unrealisedPnlPcnt: number;
    unrealisedRoePcnt: number;
    simpleQty: number;
    simpleCost: number;
    simpleValue: number;
    simplePnl: number;
    simplePnlPcnt: number;
    avgCostPrice: number;
    avgEntryPrice: number;
    breakEvenPrice: number;
    marginCallPrice: number;
    liquidationPrice: number;
    bankruptPrice: number;
    timestamp: string;
    lastPrice: number;
    lastValue: number;
}
/**
 * Best Bid/Offer Snapshots & Historical Bins
 */
export interface Quote {
    timestamp: string;
    symbol: string;
    bidSize: number;
    bidPrice: number;
    askPrice: number;
    askSize: number;
}
/**
 * Historical Settlement Data
 */
export interface Settlement {
    timestamp: string;
    symbol: string;
    settlementType: string;
    settledPrice: number;
    optionStrikePrice: number;
    optionUnderlyingPrice: number;
    bankrupt: number;
    taxBase: number;
    taxRate: number;
}
/**
 * Exchange Statistics
 */
export interface Stats {
    rootSymbol: string;
    currency: string;
    volume24h: number;
    turnover24h: number;
    openInterest: number;
    openValue: number;
}
export interface StatsHistory {
    date: string;
    rootSymbol: string;
    currency: string;
    volume: number;
    turnover: number;
}
export interface StatsUSD {
    rootSymbol: string;
    currency: string;
    turnover24h: number;
    turnover30d: number;
    turnover365d: number;
    turnover: number;
}
/**
 * Individual & Bucketed Trades
 */
export interface Trade {
    timestamp: string;
    symbol: string;
    side: string;
    size: number;
    price: number;
    tickDirection: string;
    trdMatchID: string;
    grossValue: number;
    homeNotional: number;
    foreignNotional: number;
}
export interface TradeBin {
    timestamp: string;
    symbol: string;
    open: number;
    high: number;
    low: number;
    close: number;
    trades: number;
    volume: number;
    vwap: number;
    lastSize: number;
    turnover: number;
    homeNotional: number;
    foreignNotional: number;
}
export interface Wallet {
    account: number;
    currency: string;
    prevDeposited: number;
    prevWithdrawn: number;
    prevTransferIn: number;
    prevTransferOut: number;
    prevAmount: number;
    prevTimestamp: string;
    deltaDeposited: number;
    deltaWithdrawn: number;
    deltaTransferIn: number;
    deltaTransferOut: number;
    deltaAmount: number;
    deposited: number;
    withdrawn: number;
    transferIn: number;
    transferOut: number;
    amount: number;
    pendingCredit: number;
    pendingDebit: number;
    confirmedDebit: number;
    timestamp: string;
    addr: string;
    script: string;
    withdrawalLock: string[];
}
export interface Transaction {
    transactID: string;
    account: number;
    currency: string;
    transactType: string;
    amount: number;
    walletBalance: number;
    fee: number;
    transactStatus: string;
    address: string;
    tx: string;
    text: string;
    transactTime: string;
    timestamp: string;
}
export interface AccessToken {
    id: string;
    ttl: number;
    created: string;
    userId: number;
}
export interface Affiliate {
    account: number;
    currency: string;
    prevPayout: number;
    prevTurnover: number;
    prevComm: number;
    prevTimestamp: string;
    execTurnover: number;
    execComm: number;
    totalReferrals: number;
    totalTurnover: number;
    totalComm: number;
    payoutPcnt: number;
    pendingPayout: number;
    timestamp: string;
    referrerAccount: number;
    referralDiscount: number;
    affiliatePayout: number;
}
/**
 * Account Operations
 */
export interface User {
    id: number;
    ownerId: number;
    firstname: string;
    lastname: string;
    username: string;
    email: string;
    phone: string;
    created: string;
    lastUpdated: string;
    preferences: UserPreferences;
    restrictedEngineFields: any;
    TFAEnabled: string;
    affiliateID: string;
    pgpPubKey: string;
    country: string;
    geoipCountry: string;
    geoipRegion: string;
    typ: string;
}
export interface UserCommissionsBySymbol {
    __symbol__: UserCommission;
}
export interface Margin {
    account: number;
    currency: string;
    riskLimit: number;
    prevState: string;
    state: string;
    action: string;
    amount: number;
    pendingCredit: number;
    pendingDebit: number;
    confirmedDebit: number;
    prevRealisedPnl: number;
    prevUnrealisedPnl: number;
    grossComm: number;
    grossOpenCost: number;
    grossOpenPremium: number;
    grossExecCost: number;
    grossMarkValue: number;
    riskValue: number;
    taxableMargin: number;
    initMargin: number;
    maintMargin: number;
    sessionMargin: number;
    targetExcessMargin: number;
    varMargin: number;
    realisedPnl: number;
    unrealisedPnl: number;
    indicativeTax: number;
    unrealisedProfit: number;
    syntheticMargin: number;
    walletBalance: number;
    marginBalance: number;
    marginBalancePcnt: number;
    marginLeverage: number;
    marginUsedPcnt: number;
    excessMargin: number;
    excessMarginPcnt: number;
    availableMargin: number;
    withdrawableMargin: number;
    timestamp: string;
    grossLastValue: number;
    commission: number;
}
/**
 * User communication SNS token
 */
export interface CommunicationToken {
    id: string;
    userId: number;
    deviceToken: string;
    channel: string;
}
/**
 * User Events for auditing
 */
export interface UserEvent {
    id: number;
    type: 'apiKeyCreated' | 'deleverageExecution' | 'depositConfirmed' | 'depositPending' | 'banZeroVolumeApiUser' | 'liquidationOrderPlaced' | 'login' | 'pgpMaskedEmail' | 'pgpTestEmail' | 'passwordChanged' | 'positionStateLiquidated' | 'positionStateWarning' | 'resetPasswordConfirmed' | 'resetPasswordRequest' | 'transferCanceled' | 'transferCompleted' | 'transferReceived' | 'transferRequested' | 'twoFactorDisabled' | 'twoFactorEnabled' | 'withdrawalCanceled' | 'withdrawalCompleted' | 'withdrawalConfirmed' | 'withdrawalRequested' | 'verify';
    eventType: 'apiKeyCreated' | 'deleverageExecution' | 'depositConfirmed' | 'depositPending' | 'banZeroVolumeApiUser' | 'liquidationOrderPlaced' | 'login' | 'pgpMaskedEmail' | 'pgpTestEmail' | 'passwordChanged' | 'positionStateLiquidated' | 'positionStateWarning' | 'resetPasswordConfirmed' | 'resetPasswordRequest' | 'transferCanceled' | 'transferCompleted' | 'transferReceived' | 'transferRequested' | 'twoFactorDisabled' | 'twoFactorEnabled' | 'withdrawalCanceled' | 'withdrawalCompleted' | 'withdrawalConfirmed' | 'withdrawalRequested' | 'verify';
    status: 'success' | 'failure';
    eventStatus: 'success' | 'failure';
    userId: number;
    createdById: number;
    ip: string;
    geoipCountry: string;
    geoipRegion: string;
    geoipSubRegion: string;
    eventMeta: any;
    created: string;
}
export interface UserPreferences {
    alertOnLiquidations: boolean;
    animationsEnabled: boolean;
    announcementsLastSeen: string;
    chatChannelID: number;
    colorTheme: string;
    currency: string;
    debug: boolean;
    disableEmails: string[];
    disablePush: string[];
    hideConfirmDialogs: string[];
    hideConnectionModal: boolean;
    hideFromLeaderboard: boolean;
    hideNameFromLeaderboard: boolean;
    hideNotifications: string[];
    locale: string;
    msgsSeen: string[];
    orderBookBinning: any;
    orderBookType: string;
    orderClearImmediate: boolean;
    orderControlsPlusMinus: boolean;
    showLocaleNumbers: boolean;
    sounds: string[];
    strictIPCheck: boolean;
    strictTimeout: boolean;
    tickerGroup: string;
    tickerPinned: boolean;
    tradeLayout: string;
}
export interface UserCommission {
    makerFee: number;
    takerFee: number;
    settlementFee: number;
    maxFee: number;
}
export interface AnnouncementQuery {
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     */
    columns?: string;
}
export interface ApiKeyPost {
    /**
     * Key name. This name is for reference only.
     */
    name?: string;
    /**
     * CIDR block to restrict this key to. To restrict to a single address, append "/32", e.g. 207.39.29.22/32. Leave blank or set to 0.0.0.0/0 to allow all IPs. Only one block may be set. <a href="http://software77.net/cidr-101.html">More on CIDR blocks</a>
     */
    cidr?: string;
    /**
     * Key Permissions. All keys can read margin and position data. Additional permissions must be added. Available: ["order", "orderCancel", "withdraw"].
     */
    permissions?: string;
    /**
     * Set to true to enable this key on creation. Otherwise, it must be explicitly enabled via /apiKey/enable.
     */
    enabled?: boolean;
    /**
     * OTP Token (YubiKey, Google Authenticator)
     */
    token?: string;
}
export interface ApiKeyQuery {
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
}
export interface ApiKeyDelete {
    /**
     * API Key ID (public component).
     */
    apiKeyID: string;
}
export interface ApiKeyDisablePost {
    /**
     * API Key ID (public component).
     */
    apiKeyID: string;
}
export interface ApiKeyEnablePost {
    /**
     * API Key ID (public component).
     */
    apiKeyID: string;
}
export interface ChatQuery {
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting ID for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Channel id. GET /chat/channels for ids. Leave blank for all.
     */
    channelID?: number;
}
export interface ChatPost {
    message: string;
    /**
     * Channel to post to. Default 1 (English).
     */
    channelID?: number;
}
export interface ExecutionQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface ExecutionTradeHistoryQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface FundingQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface InstrumentQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface InstrumentCompositeIndexQuery {
    /**
     * The composite index symbol.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface InsuranceQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface LeaderboardQuery {
    /**
     * Ranking type. Options: "notional", "ROE"
     */
    method?: 'notional' | 'ROE';
}
export interface LiquidationQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface OrderQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface OrderPost {
    /**
     * Instrument symbol. e.g. 'XBTUSD'.
     */
    symbol: string;
    /**
     * Order side. Valid options: Buy, Sell. Defaults to 'Buy' unless `orderQty` is negative.
     */
    side?: 'Buy' | 'Sell';
    /**
     * Deprecated: simple orders are not supported after 2018/10/26
     */
    simpleOrderQty?: number;
    /**
     * Order quantity in units of the instrument (i.e. contracts).
     */
    orderQty?: number;
    /**
     * Optional limit price for 'Limit', 'StopLimit', and 'LimitIfTouched' orders.
     */
    price?: number;
    /**
     * Optional quantity to display in the book. Use 0 for a fully hidden order.
     */
    displayQty?: number;
    /**
     * Optional trigger price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders. Use a price below the current price for stop-sell orders and buy-if-touched orders. Use `execInst` of 'MarkPrice' or 'LastPrice' to define the current price used for triggering.
     */
    stopPx?: number;
    /**
     * Optional Client Order ID. This clOrdID will come back on the order and any related executions.
     */
    clOrdID?: string;
    /**
     * Deprecated: linked orders are not supported after 2018/11/10.
     */
    clOrdLinkID?: string;
    /**
     * Optional trailing offset from the current price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders; use a negative offset for stop-sell orders and buy-if-touched orders. Optional offset from the peg price for 'Pegged' orders.
     */
    pegOffsetValue?: number;
    /**
     * Optional peg price type. Valid options: LastPeg, MidPricePeg, MarketPeg, PrimaryPeg, TrailingStopPeg.
     */
    pegPriceType?: 'LastPeg' | 'MidPricePeg' | 'MarketPeg' | 'PrimaryPeg' | 'TrailingStopPeg';
    /**
     * Order type. Valid options: Market, Limit, Stop, StopLimit, MarketIfTouched, LimitIfTouched, MarketWithLeftOverAsLimit, Pegged. Defaults to 'Limit' when `price` is specified. Defaults to 'Stop' when `stopPx` is specified. Defaults to 'StopLimit' when `price` and `stopPx` are specified.
     */
    ordType?: 'Market' | 'Limit' | 'Stop' | 'StopLimit' | 'MarketIfTouched' | 'LimitIfTouched' | 'MarketWithLeftOverAsLimit' | 'Pegged';
    /**
     * Time in force. Valid options: Day, GoodTillCancel, ImmediateOrCancel, FillOrKill. Defaults to 'GoodTillCancel' for 'Limit', 'StopLimit', 'LimitIfTouched', and 'MarketWithLeftOverAsLimit' orders.
     */
    timeInForce?: 'Day' | 'GoodTillCancel' | 'ImmediateOrCancel' | 'FillOrKill';
    /**
     * Optional execution instructions. Valid options: ParticipateDoNotInitiate, AllOrNone, MarkPrice, IndexPrice, LastPrice, Close, ReduceOnly, Fixed. 'AllOrNone' instruction requires `displayQty` to be 0. 'MarkPrice', 'IndexPrice' or 'LastPrice' instruction valid for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders.
     */
    execInst?: 'ParticipateDoNotInitiate' | 'AllOrNone' | 'MarkPrice' | 'IndexPrice' | 'LastPrice' | 'Close' | 'ReduceOnly' | 'Fixed';
    /**
     * Deprecated: linked orders are not supported after 2018/11/10.
     */
    contingencyType?: string;
    /**
     * Optional order annotation. e.g. 'Take profit'.
     */
    text?: string;
}
export interface OrderPut {
    /**
     * Order ID
     */
    orderID?: string;
    /**
     * Client Order ID. See POST /order.
     */
    origClOrdID?: string;
    /**
     * Optional new Client Order ID, requires `origClOrdID`.
     */
    clOrdID?: string;
    /**
     * Deprecated: simple orders are not supported after 2018/10/26
     */
    simpleOrderQty?: number;
    /**
     * Optional order quantity in units of the instrument (i.e. contracts).
     */
    orderQty?: number;
    /**
     * Deprecated: simple orders are not supported after 2018/10/26
     */
    simpleLeavesQty?: number;
    /**
     * Optional leaves quantity in units of the instrument (i.e. contracts). Useful for amending partially filled orders.
     */
    leavesQty?: number;
    /**
     * Optional limit price for 'Limit', 'StopLimit', and 'LimitIfTouched' orders.
     */
    price?: number;
    /**
     * Optional trigger price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders. Use a price below the current price for stop-sell orders and buy-if-touched orders.
     */
    stopPx?: number;
    /**
     * Optional trailing offset from the current price for 'Stop', 'StopLimit', 'MarketIfTouched', and 'LimitIfTouched' orders; use a negative offset for stop-sell orders and buy-if-touched orders. Optional offset from the peg price for 'Pegged' orders.
     */
    pegOffsetValue?: number;
    /**
     * Optional amend annotation. e.g. 'Adjust skew'.
     */
    text?: string;
}
export interface OrderDelete {
    /**
     * Order ID(s).
     */
    orderID?: string;
    /**
     * Client Order ID(s). See POST /order.
     */
    clOrdID?: string;
    /**
     * Optional cancellation annotation. e.g. 'Spread Exceeded'.
     */
    text?: string;
}
export interface OrderBulkPost {
    /**
     * An array of orders.
     */
    orders?: string;
}
export interface OrderBulkPut {
    /**
     * An array of orders.
     */
    orders?: string;
}
export interface OrderClosePositionPost {
    /**
     * Symbol of position to close.
     */
    symbol: string;
    /**
     * Optional limit price.
     */
    price?: number;
}
export interface OrderAllDelete {
    /**
     * Optional symbol. If provided, only cancels orders for that symbol.
     */
    symbol?: string;
    /**
     * Optional filter for cancellation. Use to only cancel some orders, e.g. `{"side": "Buy"}`.
     */
    filter?: string;
    /**
     * Optional cancellation annotation. e.g. 'Spread Exceeded'
     */
    text?: string;
}
export interface OrderCancelAllAfterPost {
    /**
     * Timeout in ms. Set to 0 to cancel this timer.
     */
    timeout: number;
}
export interface OrderBookL2Query {
    /**
     * Instrument symbol. Send a series (e.g. XBT) to get data for the nearest contract in that series.
     */
    symbol: string;
    /**
     * Orderbook depth per side. Send 0 for full depth.
     */
    depth?: number;
}
export interface PositionQuery {
    /**
     * Table filter. For example, send {"symbol": "XBTUSD"}.
     */
    filter?: string;
    /**
     * Which columns to fetch. For example, send ["columnName"].
     */
    columns?: string;
    /**
     * Number of rows to fetch.
     */
    count?: number;
}
export interface PositionIsolatePost {
    /**
     * Position symbol to isolate.
     */
    symbol: string;
    /**
     * True for isolated margin, false for cross margin.
     */
    enabled?: boolean;
}
export interface PositionRiskLimitPost {
    /**
     * Symbol of position to update risk limit on.
     */
    symbol: string;
    /**
     * New Risk Limit, in Satoshis.
     */
    riskLimit: number;
}
export interface PositionTransferMarginPost {
    /**
     * Symbol of position to isolate.
     */
    symbol: string;
    /**
     * Amount to transfer, in Satoshis. May be negative.
     */
    amount: number;
}
export interface PositionLeveragePost {
    /**
     * Symbol of position to adjust.
     */
    symbol: string;
    /**
     * Leverage value. Send a number between 0.01 and 100 to enable isolated margin with a fixed leverage. Send 0 to enable cross margin.
     */
    leverage: number;
}
export interface QuoteQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface QuoteBucketedQuery {
    /**
     * Time interval to bucket by. Available options: [1m,5m,1h,1d].
     */
    binSize?: '1m' | '5m' | '1h' | '1d';
    /**
     * If true, will send in-progress (incomplete) bins for the current time period.
     */
    partial?: boolean;
    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface SchemaQuery {
    /**
     * Optional model filter. If omitted, will return all models.
     */
    model?: string;
}
export interface SettlementQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface TradeQuery {
    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface TradeBucketedQuery {
    /**
     * Time interval to bucket by. Available options: [1m,5m,1h,1d].
     */
    binSize?: '1m' | '5m' | '1h' | '1d';
    /**
     * If true, will send in-progress (incomplete) bins for the current time period.
     */
    partial?: boolean;
    /**
     * Instrument symbol. Send a bare series (e.g. XBU) to get data for the nearest expiring contract in that series.
     *
     * You can also send a timeframe, e.g. `XBU:monthly`. Timeframes are `daily`, `weekly`, `monthly`, `quarterly`, and `biquarterly`.
     */
    symbol?: string;
    /**
     * Generic table filter. Send JSON key/value pairs, such as `{"key": "value"}`. You can key on individual fields, and do more advanced querying on timestamps. See the [Timestamp Docs](https://www.bitmex.com/app/restAPI#Timestamp-Filters) for more details.
     */
    filter?: string;
    /**
     * Array of column names to fetch. If omitted, will return all columns.
     *
     * Note that this method will always return item keys, even when not specified, so you may receive more columns that you expect.
     */
    columns?: string;
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
    /**
     * If true, will sort results newest first.
     */
    reverse?: boolean;
    /**
     * Starting date filter for results.
     */
    startTime?: string;
    /**
     * Ending date filter for results.
     */
    endTime?: string;
}
export interface UserDepositAddressQuery {
    currency?: string;
}
export interface UserWalletQuery {
    currency?: string;
}
export interface UserWalletHistoryQuery {
    currency?: string;
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Starting point for results.
     */
    start?: number;
}
export interface UserWalletSummaryQuery {
    currency?: string;
}
export interface UserExecutionHistoryQuery {
    symbol?: string;
    timestamp?: string;
}
export interface UserMinWithdrawalFeeQuery {
    currency?: string;
}
export interface UserRequestWithdrawalPost {
    /**
     * 2FA token. Required if 2FA is enabled on your account.
     */
    otpToken?: string;
    /**
     * Currency you're withdrawing. Options: `XBt`
     */
    currency?: 'XBt';
    /**
     * Amount of withdrawal currency.
     */
    amount: number;
    /**
     * Destination Address.
     */
    address: string;
    /**
     * Network fee for Bitcoin withdrawals. If not specified, a default value will be calculated based on Bitcoin network conditions. You will have a chance to confirm this via email.
     */
    fee?: number;
}
export interface UserCancelWithdrawalPost {
    token: string;
}
export interface UserConfirmWithdrawalPost {
    token: string;
}
export interface UserRequestEnableTFAPost {
    /**
     * Two-factor auth type. Supported types: 'GA' (Google Authenticator)
     */
    type?: string;
}
export interface UserConfirmEnableTFAPost {
    /**
     * Two-factor auth type. Supported types: 'GA' (Google Authenticator), 'Yubikey'
     */
    type?: string;
    /**
     * Token from your selected TFA type.
     */
    token: string;
}
export interface UserDisableTFAPost {
    /**
     * Two-factor auth type. Supported types: 'GA' (Google Authenticator)
     */
    type?: string;
    /**
     * Token from your selected TFA type.
     */
    token: string;
}
export interface UserConfirmEmailPost {
    token: string;
}
export interface UserCheckReferralCodeQuery {
    referralCode?: string;
}
export interface UserPreferencesPost {
    prefs: string;
    /**
     * If true, will overwrite all existing preferences.
     */
    overwrite?: boolean;
}
export interface UserPut {
    oldPassword?: string;
    newPassword?: string;
    newPasswordConfirm?: string;
    /**
     * Username can only be set once. To reset, email support.
     */
    username?: string;
    /**
     * Country of residence.
     */
    country?: string;
    /**
     * PGP Public Key. If specified, automated emails will be sentwith this key.
     */
    pgpPubKey?: string;
}
export interface UserMarginQuery {
    currency?: string;
}
export interface UserCommunicationTokenPost {
    token: string;
    platformAgent: string;
}
export interface UserEventQuery {
    /**
     * Number of results to fetch.
     */
    count?: number;
    /**
     * Cursor for pagination.
     */
    startId?: number;
}
